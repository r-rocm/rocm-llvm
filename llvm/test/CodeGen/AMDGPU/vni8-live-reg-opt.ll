; NOTE: Assertions have been autogenerated by utils/update_test_checks.py UTC_ARGS: --version 4
; RUN: opt -S -mtriple=amdgcn-amd-amdhsa -mcpu=gfx900 -amdgpu-late-codegenprepare -amdgpu-coerce-illegal-types=1 < %s | FileCheck --check-prefix=FEATURE %s
; RUN: opt -S -mtriple=amdgcn-amd-amdhsa -mcpu=gfx900 -amdgpu-late-codegenprepare < %s | FileCheck --check-prefix=DEFAULT %s

define amdgpu_kernel void @v3i8_liveout(ptr addrspace(1) %src1, ptr addrspace(1) %src2, ptr addrspace(1) nocapture %dst) {
; GFX906-LABEL: define amdgpu_kernel void @v3i8_liveout(
; GFX906-SAME: ptr addrspace(1) [[SRC1:%.*]], ptr addrspace(1) [[SRC2:%.*]], ptr addrspace(1) nocapture [[DST:%.*]]) #[[ATTR0:[0-9]+]] {
; GFX906-NEXT:  entry:
; GFX906-NEXT:    [[IDX:%.*]] = call i32 @llvm.amdgcn.workitem.id.x()
; GFX906-NEXT:    [[GEP1:%.*]] = getelementptr <3 x i8>, ptr addrspace(1) [[SRC1]], i32 [[IDX]]
; GFX906-NEXT:    [[VEC1:%.*]] = load <3 x i8>, ptr addrspace(1) [[GEP1]], align 4
; GFX906-NEXT:    [[TMP0:%.*]] = shufflevector <3 x i8> [[VEC1]], <3 x i8> poison, <4 x i32> <i32 0, i32 1, i32 2, i32 3>
; GFX906-NEXT:    [[VEC1_BC:%.*]] = bitcast <4 x i8> [[TMP0]] to i32
; GFX906-NEXT:    [[GEP2:%.*]] = getelementptr <3 x i8>, ptr addrspace(1) [[SRC2]], i32 [[IDX]]
; GFX906-NEXT:    [[VEC2:%.*]] = load <3 x i8>, ptr addrspace(1) [[GEP2]], align 4
; GFX906-NEXT:    [[TMP1:%.*]] = shufflevector <3 x i8> [[VEC2]], <3 x i8> poison, <4 x i32> <i32 0, i32 1, i32 2, i32 3>
; GFX906-NEXT:    [[VEC2_BC:%.*]] = bitcast <4 x i8> [[TMP1]] to i32
; GFX906-NEXT:    [[CMP:%.*]] = icmp ult i32 [[IDX]], 15
; GFX906-NEXT:    br i1 [[CMP]], label [[BB_1:%.*]], label [[BB_2:%.*]]
; GFX906:       bb.1:
; GFX906-NEXT:    br label [[BB_2]]
; GFX906:       bb.2:
; GFX906-NEXT:    [[TMP5_TC:%.*]] = phi i32 [ [[VEC1_BC]], [[ENTRY:%.*]] ], [ [[VEC2_BC]], [[BB_1]] ]
; GFX906-NEXT:    [[TMP2:%.*]] = trunc i32 [[TMP5_TC]] to i24
; GFX906-NEXT:    [[TMP3:%.*]] = bitcast i24 [[TMP2]] to <3 x i8>
; GFX906-NEXT:    store <3 x i8> [[TMP3]], ptr addrspace(1) [[DST]], align 4
; GFX906-NEXT:    ret void
;
; FEATURE-LABEL: define amdgpu_kernel void @v3i8_liveout(
; FEATURE-SAME: ptr addrspace(1) [[SRC1:%.*]], ptr addrspace(1) [[SRC2:%.*]], ptr addrspace(1) nocapture [[DST:%.*]]) #[[ATTR0:[0-9]+]] {
; FEATURE-NEXT:  entry:
; FEATURE-NEXT:    [[IDX:%.*]] = call i32 @llvm.amdgcn.workitem.id.x()
; FEATURE-NEXT:    [[GEP1:%.*]] = getelementptr <3 x i8>, ptr addrspace(1) [[SRC1]], i32 [[IDX]]
; FEATURE-NEXT:    [[VEC1:%.*]] = load <3 x i8>, ptr addrspace(1) [[GEP1]], align 4
; FEATURE-NEXT:    [[TMP0:%.*]] = shufflevector <3 x i8> [[VEC1]], <3 x i8> poison, <4 x i32> <i32 0, i32 1, i32 2, i32 3>
; FEATURE-NEXT:    [[VEC1_BC:%.*]] = bitcast <4 x i8> [[TMP0]] to i32
; FEATURE-NEXT:    [[GEP2:%.*]] = getelementptr <3 x i8>, ptr addrspace(1) [[SRC2]], i32 [[IDX]]
; FEATURE-NEXT:    [[VEC2:%.*]] = load <3 x i8>, ptr addrspace(1) [[GEP2]], align 4
; FEATURE-NEXT:    [[TMP1:%.*]] = shufflevector <3 x i8> [[VEC2]], <3 x i8> poison, <4 x i32> <i32 0, i32 1, i32 2, i32 3>
; FEATURE-NEXT:    [[VEC2_BC:%.*]] = bitcast <4 x i8> [[TMP1]] to i32
; FEATURE-NEXT:    [[CMP:%.*]] = icmp ult i32 [[IDX]], 15
; FEATURE-NEXT:    br i1 [[CMP]], label [[BB_1:%.*]], label [[BB_2:%.*]]
; FEATURE:       bb.1:
; FEATURE-NEXT:    br label [[BB_2]]
; FEATURE:       bb.2:
; FEATURE-NEXT:    [[PHI5_TC:%.*]] = phi i32 [ [[VEC1_BC]], [[ENTRY:%.*]] ], [ [[VEC2_BC]], [[BB_1]] ]
; FEATURE-NEXT:    [[TMP2:%.*]] = trunc i32 [[PHI5_TC]] to i24
; FEATURE-NEXT:    [[TMP3:%.*]] = bitcast i24 [[TMP2]] to <3 x i8>
; FEATURE-NEXT:    store <3 x i8> [[TMP3]], ptr addrspace(1) [[DST]], align 4
; FEATURE-NEXT:    ret void
;
; DEFAULT-LABEL: define amdgpu_kernel void @v3i8_liveout(
; DEFAULT-SAME: ptr addrspace(1) [[SRC1:%.*]], ptr addrspace(1) [[SRC2:%.*]], ptr addrspace(1) nocapture [[DST:%.*]]) #[[ATTR0:[0-9]+]] {
; DEFAULT-NEXT:  entry:
; DEFAULT-NEXT:    [[IDX:%.*]] = call i32 @llvm.amdgcn.workitem.id.x()
; DEFAULT-NEXT:    [[GEP1:%.*]] = getelementptr <3 x i8>, ptr addrspace(1) [[SRC1]], i32 [[IDX]]
; DEFAULT-NEXT:    [[VEC1:%.*]] = load <3 x i8>, ptr addrspace(1) [[GEP1]], align 4
; DEFAULT-NEXT:    [[GEP2:%.*]] = getelementptr <3 x i8>, ptr addrspace(1) [[SRC2]], i32 [[IDX]]
; DEFAULT-NEXT:    [[VEC2:%.*]] = load <3 x i8>, ptr addrspace(1) [[GEP2]], align 4
; DEFAULT-NEXT:    [[CMP:%.*]] = icmp ult i32 [[IDX]], 15
; DEFAULT-NEXT:    br i1 [[CMP]], label [[BB_1:%.*]], label [[BB_2:%.*]]
; DEFAULT:       bb.1:
; DEFAULT-NEXT:    br label [[BB_2]]
; DEFAULT:       bb.2:
; DEFAULT-NEXT:    [[PHI5:%.*]] = phi <3 x i8> [ [[VEC1]], [[ENTRY:%.*]] ], [ [[VEC2]], [[BB_1]] ]
; DEFAULT-NEXT:    store <3 x i8> [[PHI5]], ptr addrspace(1) [[DST]], align 4
; DEFAULT-NEXT:    ret void
;
entry:
  %idx = call i32 @llvm.amdgcn.workitem.id.x()
  %gep1 = getelementptr <3 x i8>, ptr addrspace(1) %src1, i32 %idx
  %vec1 = load <3 x i8>, ptr addrspace(1) %gep1
  %gep2 = getelementptr <3 x i8>, ptr addrspace(1) %src2, i32 %idx
  %vec2 = load <3 x i8>, ptr addrspace(1) %gep2
  %cmp = icmp ult i32 %idx, 15
  br i1 %cmp, label %bb.1, label %bb.2
bb.1:
  br label %bb.2

bb.2:
  %phi5 = phi <3 x i8> [ %vec1, %entry ], [ %vec2, %bb.1 ]
  store <3 x i8> %phi5, ptr addrspace(1) %dst, align 4
  ret void
}

define amdgpu_kernel void @v4i8_liveout(ptr addrspace(1) %src1, ptr addrspace(1) %src2, ptr addrspace(1) nocapture %dst) {
; GFX906-LABEL: define amdgpu_kernel void @v4i8_liveout(
; GFX906-SAME: ptr addrspace(1) [[SRC1:%.*]], ptr addrspace(1) [[SRC2:%.*]], ptr addrspace(1) nocapture [[DST:%.*]]) #[[ATTR0]] {
; GFX906-NEXT:  entry:
; GFX906-NEXT:    [[IDX:%.*]] = call i32 @llvm.amdgcn.workitem.id.x()
; GFX906-NEXT:    [[GEP1:%.*]] = getelementptr <4 x i8>, ptr addrspace(1) [[SRC1]], i32 [[IDX]]
; GFX906-NEXT:    [[VEC1:%.*]] = load <4 x i8>, ptr addrspace(1) [[GEP1]], align 4
; GFX906-NEXT:    [[VEC1_BC:%.*]] = bitcast <4 x i8> [[VEC1]] to i32
; GFX906-NEXT:    [[GEP2:%.*]] = getelementptr <4 x i8>, ptr addrspace(1) [[SRC2]], i32 [[IDX]]
; GFX906-NEXT:    [[VEC2:%.*]] = load <4 x i8>, ptr addrspace(1) [[GEP2]], align 4
; GFX906-NEXT:    [[VEC2_BC:%.*]] = bitcast <4 x i8> [[VEC2]] to i32
; GFX906-NEXT:    [[CMP:%.*]] = icmp ult i32 [[IDX]], 15
; GFX906-NEXT:    br i1 [[CMP]], label [[BB_1:%.*]], label [[BB_2:%.*]]
; GFX906:       bb.1:
; GFX906-NEXT:    br label [[BB_2]]
; GFX906:       bb.2:
; GFX906-NEXT:    [[TMP5_TC:%.*]] = phi i32 [ [[VEC1_BC]], [[ENTRY:%.*]] ], [ [[VEC2_BC]], [[BB_1]] ]
; GFX906-NEXT:    [[TMP5_TC_BC:%.*]] = bitcast i32 [[TMP5_TC]] to <4 x i8>
; GFX906-NEXT:    store <4 x i8> [[TMP5_TC_BC]], ptr addrspace(1) [[DST]], align 4
; GFX906-NEXT:    ret void
;
; FEATURE-LABEL: define amdgpu_kernel void @v4i8_liveout(
; FEATURE-SAME: ptr addrspace(1) [[SRC1:%.*]], ptr addrspace(1) [[SRC2:%.*]], ptr addrspace(1) nocapture [[DST:%.*]]) #[[ATTR0]] {
; FEATURE-NEXT:  entry:
; FEATURE-NEXT:    [[IDX:%.*]] = call i32 @llvm.amdgcn.workitem.id.x()
; FEATURE-NEXT:    [[GEP1:%.*]] = getelementptr <4 x i8>, ptr addrspace(1) [[SRC1]], i32 [[IDX]]
; FEATURE-NEXT:    [[VEC1:%.*]] = load <4 x i8>, ptr addrspace(1) [[GEP1]], align 4
; FEATURE-NEXT:    [[VEC1_BC:%.*]] = bitcast <4 x i8> [[VEC1]] to i32
; FEATURE-NEXT:    [[GEP2:%.*]] = getelementptr <4 x i8>, ptr addrspace(1) [[SRC2]], i32 [[IDX]]
; FEATURE-NEXT:    [[VEC2:%.*]] = load <4 x i8>, ptr addrspace(1) [[GEP2]], align 4
; FEATURE-NEXT:    [[VEC2_BC:%.*]] = bitcast <4 x i8> [[VEC2]] to i32
; FEATURE-NEXT:    [[CMP:%.*]] = icmp ult i32 [[IDX]], 15
; FEATURE-NEXT:    br i1 [[CMP]], label [[BB_1:%.*]], label [[BB_2:%.*]]
; FEATURE:       bb.1:
; FEATURE-NEXT:    br label [[BB_2]]
; FEATURE:       bb.2:
; FEATURE-NEXT:    [[PHI5_TC:%.*]] = phi i32 [ [[VEC1_BC]], [[ENTRY:%.*]] ], [ [[VEC2_BC]], [[BB_1]] ]
; FEATURE-NEXT:    [[PHI5_TC_BC:%.*]] = bitcast i32 [[PHI5_TC]] to <4 x i8>
; FEATURE-NEXT:    store <4 x i8> [[PHI5_TC_BC]], ptr addrspace(1) [[DST]], align 4
; FEATURE-NEXT:    ret void
;
; DEFAULT-LABEL: define amdgpu_kernel void @v4i8_liveout(
; DEFAULT-SAME: ptr addrspace(1) [[SRC1:%.*]], ptr addrspace(1) [[SRC2:%.*]], ptr addrspace(1) nocapture [[DST:%.*]]) #[[ATTR0]] {
; DEFAULT-NEXT:  entry:
; DEFAULT-NEXT:    [[IDX:%.*]] = call i32 @llvm.amdgcn.workitem.id.x()
; DEFAULT-NEXT:    [[GEP1:%.*]] = getelementptr <4 x i8>, ptr addrspace(1) [[SRC1]], i32 [[IDX]]
; DEFAULT-NEXT:    [[VEC1:%.*]] = load <4 x i8>, ptr addrspace(1) [[GEP1]], align 4
; DEFAULT-NEXT:    [[GEP2:%.*]] = getelementptr <4 x i8>, ptr addrspace(1) [[SRC2]], i32 [[IDX]]
; DEFAULT-NEXT:    [[VEC2:%.*]] = load <4 x i8>, ptr addrspace(1) [[GEP2]], align 4
; DEFAULT-NEXT:    [[CMP:%.*]] = icmp ult i32 [[IDX]], 15
; DEFAULT-NEXT:    br i1 [[CMP]], label [[BB_1:%.*]], label [[BB_2:%.*]]
; DEFAULT:       bb.1:
; DEFAULT-NEXT:    br label [[BB_2]]
; DEFAULT:       bb.2:
; DEFAULT-NEXT:    [[PHI5:%.*]] = phi <4 x i8> [ [[VEC1]], [[ENTRY:%.*]] ], [ [[VEC2]], [[BB_1]] ]
; DEFAULT-NEXT:    store <4 x i8> [[PHI5]], ptr addrspace(1) [[DST]], align 4
; DEFAULT-NEXT:    ret void
;
entry:
  %idx = call i32 @llvm.amdgcn.workitem.id.x()
  %gep1 = getelementptr <4 x i8>, ptr addrspace(1) %src1, i32 %idx
  %vec1 = load <4 x i8>, ptr addrspace(1) %gep1
  %gep2 = getelementptr <4 x i8>, ptr addrspace(1) %src2, i32 %idx
  %vec2 = load <4 x i8>, ptr addrspace(1) %gep2
  %cmp = icmp ult i32 %idx, 15
  br i1 %cmp, label %bb.1, label %bb.2
bb.1:
  br label %bb.2

bb.2:
  %phi5 = phi <4 x i8> [ %vec1, %entry ], [ %vec2, %bb.1 ]
  store <4 x i8> %phi5, ptr addrspace(1) %dst, align 4
  ret void
}

define amdgpu_kernel void @v5i8_liveout(ptr addrspace(1) %src1, ptr addrspace(1) %src2, ptr addrspace(1) nocapture %dst) {
; GFX906-LABEL: define amdgpu_kernel void @v5i8_liveout(
; GFX906-SAME: ptr addrspace(1) [[SRC1:%.*]], ptr addrspace(1) [[SRC2:%.*]], ptr addrspace(1) nocapture [[DST:%.*]]) #[[ATTR0]] {
; GFX906-NEXT:  entry:
; GFX906-NEXT:    [[IDX:%.*]] = call i32 @llvm.amdgcn.workitem.id.x()
; GFX906-NEXT:    [[GEP1:%.*]] = getelementptr <5 x i8>, ptr addrspace(1) [[SRC1]], i32 [[IDX]]
; GFX906-NEXT:    [[VEC1:%.*]] = load <5 x i8>, ptr addrspace(1) [[GEP1]], align 8
; GFX906-NEXT:    [[TMP0:%.*]] = shufflevector <5 x i8> [[VEC1]], <5 x i8> poison, <8 x i32> <i32 0, i32 1, i32 2, i32 3, i32 4, i32 5, i32 5, i32 5>
; GFX906-NEXT:    [[VEC1_BC:%.*]] = bitcast <8 x i8> [[TMP0]] to <2 x i32>
; GFX906-NEXT:    [[GEP2:%.*]] = getelementptr <5 x i8>, ptr addrspace(1) [[SRC2]], i32 [[IDX]]
; GFX906-NEXT:    [[VEC2:%.*]] = load <5 x i8>, ptr addrspace(1) [[GEP2]], align 8
; GFX906-NEXT:    [[TMP1:%.*]] = shufflevector <5 x i8> [[VEC2]], <5 x i8> poison, <8 x i32> <i32 0, i32 1, i32 2, i32 3, i32 4, i32 5, i32 5, i32 5>
; GFX906-NEXT:    [[VEC2_BC:%.*]] = bitcast <8 x i8> [[TMP1]] to <2 x i32>
; GFX906-NEXT:    [[CMP:%.*]] = icmp ult i32 [[IDX]], 15
; GFX906-NEXT:    br i1 [[CMP]], label [[BB_1:%.*]], label [[BB_2:%.*]]
; GFX906:       bb.1:
; GFX906-NEXT:    br label [[BB_2]]
; GFX906:       bb.2:
; GFX906-NEXT:    [[TMP5_TC:%.*]] = phi <2 x i32> [ [[VEC1_BC]], [[ENTRY:%.*]] ], [ [[VEC2_BC]], [[BB_1]] ]
; GFX906-NEXT:    [[TMP2:%.*]] = bitcast <2 x i32> [[TMP5_TC]] to <8 x i8>
; GFX906-NEXT:    [[TMP3:%.*]] = shufflevector <8 x i8> [[TMP2]], <8 x i8> poison, <5 x i32> <i32 0, i32 1, i32 2, i32 3, i32 4>
; GFX906-NEXT:    store <5 x i8> [[TMP3]], ptr addrspace(1) [[DST]], align 4
; GFX906-NEXT:    ret void
;
; FEATURE-LABEL: define amdgpu_kernel void @v5i8_liveout(
; FEATURE-SAME: ptr addrspace(1) [[SRC1:%.*]], ptr addrspace(1) [[SRC2:%.*]], ptr addrspace(1) nocapture [[DST:%.*]]) #[[ATTR0]] {
; FEATURE-NEXT:  entry:
; FEATURE-NEXT:    [[IDX:%.*]] = call i32 @llvm.amdgcn.workitem.id.x()
; FEATURE-NEXT:    [[GEP1:%.*]] = getelementptr <5 x i8>, ptr addrspace(1) [[SRC1]], i32 [[IDX]]
; FEATURE-NEXT:    [[VEC1:%.*]] = load <5 x i8>, ptr addrspace(1) [[GEP1]], align 8
; FEATURE-NEXT:    [[TMP0:%.*]] = shufflevector <5 x i8> [[VEC1]], <5 x i8> poison, <8 x i32> <i32 0, i32 1, i32 2, i32 3, i32 4, i32 5, i32 5, i32 5>
; FEATURE-NEXT:    [[VEC1_BC:%.*]] = bitcast <8 x i8> [[TMP0]] to <2 x i32>
; FEATURE-NEXT:    [[GEP2:%.*]] = getelementptr <5 x i8>, ptr addrspace(1) [[SRC2]], i32 [[IDX]]
; FEATURE-NEXT:    [[VEC2:%.*]] = load <5 x i8>, ptr addrspace(1) [[GEP2]], align 8
; FEATURE-NEXT:    [[TMP1:%.*]] = shufflevector <5 x i8> [[VEC2]], <5 x i8> poison, <8 x i32> <i32 0, i32 1, i32 2, i32 3, i32 4, i32 5, i32 5, i32 5>
; FEATURE-NEXT:    [[VEC2_BC:%.*]] = bitcast <8 x i8> [[TMP1]] to <2 x i32>
; FEATURE-NEXT:    [[CMP:%.*]] = icmp ult i32 [[IDX]], 15
; FEATURE-NEXT:    br i1 [[CMP]], label [[BB_1:%.*]], label [[BB_2:%.*]]
; FEATURE:       bb.1:
; FEATURE-NEXT:    br label [[BB_2]]
; FEATURE:       bb.2:
; FEATURE-NEXT:    [[PHI5_TC:%.*]] = phi <2 x i32> [ [[VEC1_BC]], [[ENTRY:%.*]] ], [ [[VEC2_BC]], [[BB_1]] ]
; FEATURE-NEXT:    [[TMP2:%.*]] = bitcast <2 x i32> [[PHI5_TC]] to <8 x i8>
; FEATURE-NEXT:    [[TMP3:%.*]] = shufflevector <8 x i8> [[TMP2]], <8 x i8> poison, <5 x i32> <i32 0, i32 1, i32 2, i32 3, i32 4>
; FEATURE-NEXT:    store <5 x i8> [[TMP3]], ptr addrspace(1) [[DST]], align 4
; FEATURE-NEXT:    ret void
;
; DEFAULT-LABEL: define amdgpu_kernel void @v5i8_liveout(
; DEFAULT-SAME: ptr addrspace(1) [[SRC1:%.*]], ptr addrspace(1) [[SRC2:%.*]], ptr addrspace(1) nocapture [[DST:%.*]]) #[[ATTR0]] {
; DEFAULT-NEXT:  entry:
; DEFAULT-NEXT:    [[IDX:%.*]] = call i32 @llvm.amdgcn.workitem.id.x()
; DEFAULT-NEXT:    [[GEP1:%.*]] = getelementptr <5 x i8>, ptr addrspace(1) [[SRC1]], i32 [[IDX]]
; DEFAULT-NEXT:    [[VEC1:%.*]] = load <5 x i8>, ptr addrspace(1) [[GEP1]], align 8
; DEFAULT-NEXT:    [[GEP2:%.*]] = getelementptr <5 x i8>, ptr addrspace(1) [[SRC2]], i32 [[IDX]]
; DEFAULT-NEXT:    [[VEC2:%.*]] = load <5 x i8>, ptr addrspace(1) [[GEP2]], align 8
; DEFAULT-NEXT:    [[CMP:%.*]] = icmp ult i32 [[IDX]], 15
; DEFAULT-NEXT:    br i1 [[CMP]], label [[BB_1:%.*]], label [[BB_2:%.*]]
; DEFAULT:       bb.1:
; DEFAULT-NEXT:    br label [[BB_2]]
; DEFAULT:       bb.2:
; DEFAULT-NEXT:    [[PHI5:%.*]] = phi <5 x i8> [ [[VEC1]], [[ENTRY:%.*]] ], [ [[VEC2]], [[BB_1]] ]
; DEFAULT-NEXT:    store <5 x i8> [[PHI5]], ptr addrspace(1) [[DST]], align 4
; DEFAULT-NEXT:    ret void
;
entry:
  %idx = call i32 @llvm.amdgcn.workitem.id.x()
  %gep1 = getelementptr <5 x i8>, ptr addrspace(1) %src1, i32 %idx
  %vec1 = load <5 x i8>, ptr addrspace(1) %gep1
  %gep2 = getelementptr <5 x i8>, ptr addrspace(1) %src2, i32 %idx
  %vec2 = load <5 x i8>, ptr addrspace(1) %gep2
  %cmp = icmp ult i32 %idx, 15
  br i1 %cmp, label %bb.1, label %bb.2
bb.1:
  br label %bb.2

bb.2:
  %phi5 = phi <5 x i8> [ %vec1, %entry ], [ %vec2, %bb.1 ]
  store <5 x i8> %phi5, ptr addrspace(1) %dst, align 4
  ret void
}

define amdgpu_kernel void @v8i8_liveout(ptr addrspace(1) %src1, ptr addrspace(1) %src2, ptr addrspace(1) nocapture %dst) {
; GFX906-LABEL: define amdgpu_kernel void @v8i8_liveout(
; GFX906-SAME: ptr addrspace(1) [[SRC1:%.*]], ptr addrspace(1) [[SRC2:%.*]], ptr addrspace(1) nocapture [[DST:%.*]]) #[[ATTR0]] {
; GFX906-NEXT:  entry:
; GFX906-NEXT:    [[IDX:%.*]] = call i32 @llvm.amdgcn.workitem.id.x()
; GFX906-NEXT:    [[GEP1:%.*]] = getelementptr <8 x i8>, ptr addrspace(1) [[SRC1]], i32 [[IDX]]
; GFX906-NEXT:    [[VEC1:%.*]] = load <8 x i8>, ptr addrspace(1) [[GEP1]], align 8
; GFX906-NEXT:    [[VEC1_BC:%.*]] = bitcast <8 x i8> [[VEC1]] to <2 x i32>
; GFX906-NEXT:    [[GEP2:%.*]] = getelementptr <8 x i8>, ptr addrspace(1) [[SRC2]], i32 [[IDX]]
; GFX906-NEXT:    [[VEC2:%.*]] = load <8 x i8>, ptr addrspace(1) [[GEP2]], align 8
; GFX906-NEXT:    [[VEC2_BC:%.*]] = bitcast <8 x i8> [[VEC2]] to <2 x i32>
; GFX906-NEXT:    [[CMP:%.*]] = icmp ult i32 [[IDX]], 15
; GFX906-NEXT:    br i1 [[CMP]], label [[BB_1:%.*]], label [[BB_2:%.*]]
; GFX906:       bb.1:
; GFX906-NEXT:    br label [[BB_2]]
; GFX906:       bb.2:
; GFX906-NEXT:    [[TMP5_TC:%.*]] = phi <2 x i32> [ [[VEC1_BC]], [[ENTRY:%.*]] ], [ [[VEC2_BC]], [[BB_1]] ]
; GFX906-NEXT:    [[TMP5_TC_BC:%.*]] = bitcast <2 x i32> [[TMP5_TC]] to <8 x i8>
; GFX906-NEXT:    store <8 x i8> [[TMP5_TC_BC]], ptr addrspace(1) [[DST]], align 4
; GFX906-NEXT:    ret void
;
; FEATURE-LABEL: define amdgpu_kernel void @v8i8_liveout(
; FEATURE-SAME: ptr addrspace(1) [[SRC1:%.*]], ptr addrspace(1) [[SRC2:%.*]], ptr addrspace(1) nocapture [[DST:%.*]]) #[[ATTR0]] {
; FEATURE-NEXT:  entry:
; FEATURE-NEXT:    [[IDX:%.*]] = call i32 @llvm.amdgcn.workitem.id.x()
; FEATURE-NEXT:    [[GEP1:%.*]] = getelementptr <8 x i8>, ptr addrspace(1) [[SRC1]], i32 [[IDX]]
; FEATURE-NEXT:    [[VEC1:%.*]] = load <8 x i8>, ptr addrspace(1) [[GEP1]], align 8
; FEATURE-NEXT:    [[VEC1_BC:%.*]] = bitcast <8 x i8> [[VEC1]] to <2 x i32>
; FEATURE-NEXT:    [[GEP2:%.*]] = getelementptr <8 x i8>, ptr addrspace(1) [[SRC2]], i32 [[IDX]]
; FEATURE-NEXT:    [[VEC2:%.*]] = load <8 x i8>, ptr addrspace(1) [[GEP2]], align 8
; FEATURE-NEXT:    [[VEC2_BC:%.*]] = bitcast <8 x i8> [[VEC2]] to <2 x i32>
; FEATURE-NEXT:    [[CMP:%.*]] = icmp ult i32 [[IDX]], 15
; FEATURE-NEXT:    br i1 [[CMP]], label [[BB_1:%.*]], label [[BB_2:%.*]]
; FEATURE:       bb.1:
; FEATURE-NEXT:    br label [[BB_2]]
; FEATURE:       bb.2:
; FEATURE-NEXT:    [[PHI5_TC:%.*]] = phi <2 x i32> [ [[VEC1_BC]], [[ENTRY:%.*]] ], [ [[VEC2_BC]], [[BB_1]] ]
; FEATURE-NEXT:    [[PHI5_TC_BC:%.*]] = bitcast <2 x i32> [[PHI5_TC]] to <8 x i8>
; FEATURE-NEXT:    store <8 x i8> [[PHI5_TC_BC]], ptr addrspace(1) [[DST]], align 4
; FEATURE-NEXT:    ret void
;
; DEFAULT-LABEL: define amdgpu_kernel void @v8i8_liveout(
; DEFAULT-SAME: ptr addrspace(1) [[SRC1:%.*]], ptr addrspace(1) [[SRC2:%.*]], ptr addrspace(1) nocapture [[DST:%.*]]) #[[ATTR0]] {
; DEFAULT-NEXT:  entry:
; DEFAULT-NEXT:    [[IDX:%.*]] = call i32 @llvm.amdgcn.workitem.id.x()
; DEFAULT-NEXT:    [[GEP1:%.*]] = getelementptr <8 x i8>, ptr addrspace(1) [[SRC1]], i32 [[IDX]]
; DEFAULT-NEXT:    [[VEC1:%.*]] = load <8 x i8>, ptr addrspace(1) [[GEP1]], align 8
; DEFAULT-NEXT:    [[GEP2:%.*]] = getelementptr <8 x i8>, ptr addrspace(1) [[SRC2]], i32 [[IDX]]
; DEFAULT-NEXT:    [[VEC2:%.*]] = load <8 x i8>, ptr addrspace(1) [[GEP2]], align 8
; DEFAULT-NEXT:    [[CMP:%.*]] = icmp ult i32 [[IDX]], 15
; DEFAULT-NEXT:    br i1 [[CMP]], label [[BB_1:%.*]], label [[BB_2:%.*]]
; DEFAULT:       bb.1:
; DEFAULT-NEXT:    br label [[BB_2]]
; DEFAULT:       bb.2:
; DEFAULT-NEXT:    [[PHI5:%.*]] = phi <8 x i8> [ [[VEC1]], [[ENTRY:%.*]] ], [ [[VEC2]], [[BB_1]] ]
; DEFAULT-NEXT:    store <8 x i8> [[PHI5]], ptr addrspace(1) [[DST]], align 4
; DEFAULT-NEXT:    ret void
;
entry:
  %idx = call i32 @llvm.amdgcn.workitem.id.x()
  %gep1 = getelementptr <8 x i8>, ptr addrspace(1) %src1, i32 %idx
  %vec1 = load <8 x i8>, ptr addrspace(1) %gep1
  %gep2 = getelementptr <8 x i8>, ptr addrspace(1) %src2, i32 %idx
  %vec2 = load <8 x i8>, ptr addrspace(1) %gep2
  %cmp = icmp ult i32 %idx, 15
  br i1 %cmp, label %bb.1, label %bb.2
bb.1:
  br label %bb.2

bb.2:
  %phi5 = phi <8 x i8> [ %vec1, %entry ], [ %vec2, %bb.1 ]
  store <8 x i8> %phi5, ptr addrspace(1) %dst, align 4
  ret void
}

define amdgpu_kernel void @repeat_successor(i32 %in, ptr addrspace(1) %src1, ptr addrspace(1) %src2, ptr addrspace(1) nocapture %dst) {
; GFX906-LABEL: define amdgpu_kernel void @repeat_successor(
; GFX906-SAME: i32 [[IN:%.*]], ptr addrspace(1) [[SRC1:%.*]], ptr addrspace(1) [[SRC2:%.*]], ptr addrspace(1) nocapture [[DST:%.*]]) #[[ATTR0]] {
; GFX906-NEXT:  entry:
; GFX906-NEXT:    [[IDX:%.*]] = call i32 @llvm.amdgcn.workitem.id.x()
; GFX906-NEXT:    [[GEP1:%.*]] = getelementptr <4 x i8>, ptr addrspace(1) [[SRC1]], i32 [[IDX]]
; GFX906-NEXT:    [[VEC1:%.*]] = load <4 x i8>, ptr addrspace(1) [[GEP1]], align 4
; GFX906-NEXT:    [[VEC1_BC:%.*]] = bitcast <4 x i8> [[VEC1]] to i32
; GFX906-NEXT:    [[GEP2:%.*]] = getelementptr <4 x i8>, ptr addrspace(1) [[SRC2]], i32 [[IDX]]
; GFX906-NEXT:    [[VEC2:%.*]] = load <4 x i8>, ptr addrspace(1) [[GEP2]], align 4
; GFX906-NEXT:    [[VEC2_BC:%.*]] = bitcast <4 x i8> [[VEC2]] to i32
; GFX906-NEXT:    switch i32 [[IN]], label [[RETURN:%.*]] [
; GFX906-NEXT:      i32 1, label [[RETURN_SINK_SPLIT:%.*]]
; GFX906-NEXT:      i32 2, label [[RETURN_SINK_SPLIT]]
; GFX906-NEXT:      i32 3, label [[SW_BB5:%.*]]
; GFX906-NEXT:    ]
; GFX906:       sw.bb5:
; GFX906-NEXT:    br label [[RETURN_SINK_SPLIT]]
; GFX906:       return.sink.split:
; GFX906-NEXT:    [[TMP5_TC:%.*]] = phi i32 [ [[VEC2_BC]], [[SW_BB5]] ], [ [[VEC1_BC]], [[ENTRY:%.*]] ], [ [[VEC1_BC]], [[ENTRY]] ]
; GFX906-NEXT:    [[TMP5_TC_BC:%.*]] = bitcast i32 [[TMP5_TC]] to <4 x i8>
; GFX906-NEXT:    store <4 x i8> [[TMP5_TC_BC]], ptr addrspace(1) [[DST]], align 4
; GFX906-NEXT:    ret void
; GFX906:       return:
; GFX906-NEXT:    ret void
;
; FEATURE-LABEL: define amdgpu_kernel void @repeat_successor(
; FEATURE-SAME: i32 [[IN:%.*]], ptr addrspace(1) [[SRC1:%.*]], ptr addrspace(1) [[SRC2:%.*]], ptr addrspace(1) nocapture [[DST:%.*]]) #[[ATTR0]] {
; FEATURE-NEXT:  entry:
; FEATURE-NEXT:    [[IDX:%.*]] = call i32 @llvm.amdgcn.workitem.id.x()
; FEATURE-NEXT:    [[GEP1:%.*]] = getelementptr <4 x i8>, ptr addrspace(1) [[SRC1]], i32 [[IDX]]
; FEATURE-NEXT:    [[VEC1:%.*]] = load <4 x i8>, ptr addrspace(1) [[GEP1]], align 4
; FEATURE-NEXT:    [[VEC1_BC:%.*]] = bitcast <4 x i8> [[VEC1]] to i32
; FEATURE-NEXT:    [[GEP2:%.*]] = getelementptr <4 x i8>, ptr addrspace(1) [[SRC2]], i32 [[IDX]]
; FEATURE-NEXT:    [[VEC2:%.*]] = load <4 x i8>, ptr addrspace(1) [[GEP2]], align 4
; FEATURE-NEXT:    [[VEC2_BC:%.*]] = bitcast <4 x i8> [[VEC2]] to i32
; FEATURE-NEXT:    switch i32 [[IN]], label [[RETURN:%.*]] [
; FEATURE-NEXT:      i32 1, label [[RETURN_SINK_SPLIT:%.*]]
; FEATURE-NEXT:      i32 2, label [[RETURN_SINK_SPLIT]]
; FEATURE-NEXT:      i32 3, label [[SW_BB5:%.*]]
; FEATURE-NEXT:    ]
; FEATURE:       sw.bb5:
; FEATURE-NEXT:    br label [[RETURN_SINK_SPLIT]]
; FEATURE:       return.sink.split:
; FEATURE-NEXT:    [[PHI5_TC:%.*]] = phi i32 [ [[VEC2_BC]], [[SW_BB5]] ], [ [[VEC1_BC]], [[ENTRY:%.*]] ], [ [[VEC1_BC]], [[ENTRY]] ]
; FEATURE-NEXT:    [[PHI5_TC_BC:%.*]] = bitcast i32 [[PHI5_TC]] to <4 x i8>
; FEATURE-NEXT:    store <4 x i8> [[PHI5_TC_BC]], ptr addrspace(1) [[DST]], align 4
; FEATURE-NEXT:    ret void
; FEATURE:       return:
; FEATURE-NEXT:    ret void
;
; DEFAULT-LABEL: define amdgpu_kernel void @repeat_successor(
; DEFAULT-SAME: i32 [[IN:%.*]], ptr addrspace(1) [[SRC1:%.*]], ptr addrspace(1) [[SRC2:%.*]], ptr addrspace(1) nocapture [[DST:%.*]]) #[[ATTR0]] {
; DEFAULT-NEXT:  entry:
; DEFAULT-NEXT:    [[IDX:%.*]] = call i32 @llvm.amdgcn.workitem.id.x()
; DEFAULT-NEXT:    [[GEP1:%.*]] = getelementptr <4 x i8>, ptr addrspace(1) [[SRC1]], i32 [[IDX]]
; DEFAULT-NEXT:    [[VEC1:%.*]] = load <4 x i8>, ptr addrspace(1) [[GEP1]], align 4
; DEFAULT-NEXT:    [[GEP2:%.*]] = getelementptr <4 x i8>, ptr addrspace(1) [[SRC2]], i32 [[IDX]]
; DEFAULT-NEXT:    [[VEC2:%.*]] = load <4 x i8>, ptr addrspace(1) [[GEP2]], align 4
; DEFAULT-NEXT:    switch i32 [[IN]], label [[RETURN:%.*]] [
; DEFAULT-NEXT:      i32 1, label [[RETURN_SINK_SPLIT:%.*]]
; DEFAULT-NEXT:      i32 2, label [[RETURN_SINK_SPLIT]]
; DEFAULT-NEXT:      i32 3, label [[SW_BB5:%.*]]
; DEFAULT-NEXT:    ]
; DEFAULT:       sw.bb5:
; DEFAULT-NEXT:    br label [[RETURN_SINK_SPLIT]]
; DEFAULT:       return.sink.split:
; DEFAULT-NEXT:    [[PHI5:%.*]] = phi <4 x i8> [ [[VEC2]], [[SW_BB5]] ], [ [[VEC1]], [[ENTRY:%.*]] ], [ [[VEC1]], [[ENTRY]] ]
; DEFAULT-NEXT:    store <4 x i8> [[PHI5]], ptr addrspace(1) [[DST]], align 4
; DEFAULT-NEXT:    ret void
; DEFAULT:       return:
; DEFAULT-NEXT:    ret void
;
entry:
  %idx = call i32 @llvm.amdgcn.workitem.id.x()
  %gep1 = getelementptr <4 x i8>, ptr addrspace(1) %src1, i32 %idx
  %vec1 = load <4 x i8>, ptr addrspace(1) %gep1
  %gep2 = getelementptr <4 x i8>, ptr addrspace(1) %src2, i32 %idx
  %vec2 = load <4 x i8>, ptr addrspace(1) %gep2
  switch i32 %in, label %return [
  i32 1, label %return.sink.split
  i32 2, label %return.sink.split
  i32 3, label %sw.bb5
  ]

sw.bb5:
  br label %return.sink.split

return.sink.split:
  %phi5 = phi <4 x i8> [ %vec2, %sw.bb5 ], [ %vec1, %entry ], [ %vec1, %entry ]
  store <4 x i8> %phi5, ptr addrspace(1) %dst, align 4
  ret void

return:
  ret void
}

define amdgpu_kernel void @v8i8_phi_chain(ptr addrspace(1) %src1, ptr addrspace(1) %src2, ptr addrspace(1) nocapture %dst0, ptr addrspace(1) nocapture %dst1) {
; GFX906-LABEL: define amdgpu_kernel void @v8i8_phi_chain(
; GFX906-SAME: ptr addrspace(1) [[SRC1:%.*]], ptr addrspace(1) [[SRC2:%.*]], ptr addrspace(1) nocapture [[DST0:%.*]], ptr addrspace(1) nocapture [[DST1:%.*]]) #[[ATTR0]] {
; GFX906-NEXT:  entry:
; GFX906-NEXT:    [[IDX:%.*]] = call i32 @llvm.amdgcn.workitem.id.x()
; GFX906-NEXT:    [[GEP1:%.*]] = getelementptr <8 x i8>, ptr addrspace(1) [[SRC1]], i32 [[IDX]]
; GFX906-NEXT:    [[VEC1:%.*]] = load <8 x i8>, ptr addrspace(1) [[GEP1]], align 8
; GFX906-NEXT:    [[VEC1_BC:%.*]] = bitcast <8 x i8> [[VEC1]] to <2 x i32>
; GFX906-NEXT:    [[GEP2:%.*]] = getelementptr <8 x i8>, ptr addrspace(1) [[SRC2]], i32 [[IDX]]
; GFX906-NEXT:    [[VEC2:%.*]] = load <8 x i8>, ptr addrspace(1) [[GEP2]], align 8
; GFX906-NEXT:    [[VEC2_BC:%.*]] = bitcast <8 x i8> [[VEC2]] to <2 x i32>
; GFX906-NEXT:    [[CMP:%.*]] = icmp ult i32 [[IDX]], 15
; GFX906-NEXT:    br i1 [[CMP]], label [[BB_1:%.*]], label [[BB_2:%.*]]
; GFX906:       bb.1:
; GFX906-NEXT:    [[CMP2:%.*]] = icmp ult i32 [[IDX]], 7
; GFX906-NEXT:    br i1 [[CMP2]], label [[BB_2]], label [[BB_3:%.*]]
; GFX906:       bb.2:
; GFX906-NEXT:    [[TMP5_TC:%.*]] = phi <2 x i32> [ [[VEC1_BC]], [[ENTRY:%.*]] ], [ [[VEC2_BC]], [[BB_1]] ]
; GFX906-NEXT:    [[TMP5_TC_BC:%.*]] = bitcast <2 x i32> [[TMP5_TC]] to <8 x i8>
; GFX906-NEXT:    store <8 x i8> [[TMP5_TC_BC]], ptr addrspace(1) [[DST0]], align 4
; GFX906-NEXT:    br label [[BB_3]]
; GFX906:       bb.3:
; GFX906-NEXT:    [[TMP7_TC:%.*]] = phi <2 x i32> [ [[VEC2_BC]], [[BB_1]] ], [ [[TMP5_TC]], [[BB_2]] ]
; GFX906-NEXT:    [[TMP7_TC_BC:%.*]] = bitcast <2 x i32> [[TMP7_TC]] to <8 x i8>
; GFX906-NEXT:    store <8 x i8> [[TMP7_TC_BC]], ptr addrspace(1) [[DST1]], align 4
; GFX906-NEXT:    ret void
;
; FEATURE-LABEL: define amdgpu_kernel void @v8i8_phi_chain(
; FEATURE-SAME: ptr addrspace(1) [[SRC1:%.*]], ptr addrspace(1) [[SRC2:%.*]], ptr addrspace(1) nocapture [[DST0:%.*]], ptr addrspace(1) nocapture [[DST1:%.*]]) #[[ATTR0]] {
; FEATURE-NEXT:  entry:
; FEATURE-NEXT:    [[IDX:%.*]] = call i32 @llvm.amdgcn.workitem.id.x()
; FEATURE-NEXT:    [[GEP1:%.*]] = getelementptr <8 x i8>, ptr addrspace(1) [[SRC1]], i32 [[IDX]]
; FEATURE-NEXT:    [[VEC1:%.*]] = load <8 x i8>, ptr addrspace(1) [[GEP1]], align 8
; FEATURE-NEXT:    [[VEC1_BC:%.*]] = bitcast <8 x i8> [[VEC1]] to <2 x i32>
; FEATURE-NEXT:    [[GEP2:%.*]] = getelementptr <8 x i8>, ptr addrspace(1) [[SRC2]], i32 [[IDX]]
; FEATURE-NEXT:    [[VEC2:%.*]] = load <8 x i8>, ptr addrspace(1) [[GEP2]], align 8
; FEATURE-NEXT:    [[VEC2_BC:%.*]] = bitcast <8 x i8> [[VEC2]] to <2 x i32>
; FEATURE-NEXT:    [[CMP:%.*]] = icmp ult i32 [[IDX]], 15
; FEATURE-NEXT:    br i1 [[CMP]], label [[BB_1:%.*]], label [[BB_2:%.*]]
; FEATURE:       bb.1:
; FEATURE-NEXT:    [[CMP2:%.*]] = icmp ult i32 [[IDX]], 7
; FEATURE-NEXT:    br i1 [[CMP2]], label [[BB_2]], label [[BB_3:%.*]]
; FEATURE:       bb.2:
; FEATURE-NEXT:    [[PHI5_TC:%.*]] = phi <2 x i32> [ [[VEC1_BC]], [[ENTRY:%.*]] ], [ [[VEC2_BC]], [[BB_1]] ]
; FEATURE-NEXT:    [[PHI5_TC_BC:%.*]] = bitcast <2 x i32> [[PHI5_TC]] to <8 x i8>
; FEATURE-NEXT:    store <8 x i8> [[PHI5_TC_BC]], ptr addrspace(1) [[DST0]], align 4
; FEATURE-NEXT:    br label [[BB_3]]
; FEATURE:       bb.3:
; FEATURE-NEXT:    [[PHI7_TC:%.*]] = phi <2 x i32> [ [[VEC2_BC]], [[BB_1]] ], [ [[PHI5_TC]], [[BB_2]] ]
; FEATURE-NEXT:    [[PHI7_TC_BC:%.*]] = bitcast <2 x i32> [[PHI7_TC]] to <8 x i8>
; FEATURE-NEXT:    store <8 x i8> [[PHI7_TC_BC]], ptr addrspace(1) [[DST1]], align 4
; FEATURE-NEXT:    ret void
;
; DEFAULT-LABEL: define amdgpu_kernel void @v8i8_phi_chain(
; DEFAULT-SAME: ptr addrspace(1) [[SRC1:%.*]], ptr addrspace(1) [[SRC2:%.*]], ptr addrspace(1) nocapture [[DST0:%.*]], ptr addrspace(1) nocapture [[DST1:%.*]]) #[[ATTR0]] {
; DEFAULT-NEXT:  entry:
; DEFAULT-NEXT:    [[IDX:%.*]] = call i32 @llvm.amdgcn.workitem.id.x()
; DEFAULT-NEXT:    [[GEP1:%.*]] = getelementptr <8 x i8>, ptr addrspace(1) [[SRC1]], i32 [[IDX]]
; DEFAULT-NEXT:    [[VEC1:%.*]] = load <8 x i8>, ptr addrspace(1) [[GEP1]], align 8
; DEFAULT-NEXT:    [[GEP2:%.*]] = getelementptr <8 x i8>, ptr addrspace(1) [[SRC2]], i32 [[IDX]]
; DEFAULT-NEXT:    [[VEC2:%.*]] = load <8 x i8>, ptr addrspace(1) [[GEP2]], align 8
; DEFAULT-NEXT:    [[CMP:%.*]] = icmp ult i32 [[IDX]], 15
; DEFAULT-NEXT:    br i1 [[CMP]], label [[BB_1:%.*]], label [[BB_2:%.*]]
; DEFAULT:       bb.1:
; DEFAULT-NEXT:    [[CMP2:%.*]] = icmp ult i32 [[IDX]], 7
; DEFAULT-NEXT:    br i1 [[CMP2]], label [[BB_2]], label [[BB_3:%.*]]
; DEFAULT:       bb.2:
; DEFAULT-NEXT:    [[PHI5:%.*]] = phi <8 x i8> [ [[VEC1]], [[ENTRY:%.*]] ], [ [[VEC2]], [[BB_1]] ]
; DEFAULT-NEXT:    store <8 x i8> [[PHI5]], ptr addrspace(1) [[DST0]], align 4
; DEFAULT-NEXT:    br label [[BB_3]]
; DEFAULT:       bb.3:
; DEFAULT-NEXT:    [[PHI7:%.*]] = phi <8 x i8> [ [[VEC2]], [[BB_1]] ], [ [[PHI5]], [[BB_2]] ]
; DEFAULT-NEXT:    store <8 x i8> [[PHI7]], ptr addrspace(1) [[DST1]], align 4
; DEFAULT-NEXT:    ret void
;
entry:
  %idx = call i32 @llvm.amdgcn.workitem.id.x()
  %gep1 = getelementptr <8 x i8>, ptr addrspace(1) %src1, i32 %idx
  %vec1 = load <8 x i8>, ptr addrspace(1) %gep1
  %gep2 = getelementptr <8 x i8>, ptr addrspace(1) %src2, i32 %idx
  %vec2 = load <8 x i8>, ptr addrspace(1) %gep2
  %cmp = icmp ult i32 %idx, 15
  br i1 %cmp, label %bb.1, label %bb.2
bb.1:
  %cmp2 = icmp ult i32 %idx, 7
  br i1 %cmp2, label %bb.2, label %bb.3

bb.2:
  %phi5 = phi <8 x i8> [ %vec1, %entry ], [ %vec2, %bb.1 ]
  store <8 x i8> %phi5, ptr addrspace(1) %dst0, align 4
  br label %bb.3

bb.3:
  %phi7 = phi <8 x i8> [ %vec2, %bb.1], [%phi5, %bb.2]
  store <8 x i8> %phi7, ptr addrspace(1) %dst1, align 4
  ret void
}

define amdgpu_kernel void @v8i8_multi_block(ptr addrspace(1) %src1, ptr addrspace(1) %src2, ptr addrspace(1) nocapture %dst0, ptr addrspace(1) nocapture %dst1) {
; GFX906-LABEL: define amdgpu_kernel void @v8i8_multi_block(
; GFX906-SAME: ptr addrspace(1) [[SRC1:%.*]], ptr addrspace(1) [[SRC2:%.*]], ptr addrspace(1) nocapture [[DST0:%.*]], ptr addrspace(1) nocapture [[DST1:%.*]]) #[[ATTR0]] {
; GFX906-NEXT:  entry:
; GFX906-NEXT:    [[IDX:%.*]] = call i32 @llvm.amdgcn.workitem.id.x()
; GFX906-NEXT:    [[GEP1:%.*]] = getelementptr <8 x i8>, ptr addrspace(1) [[SRC1]], i32 [[IDX]]
; GFX906-NEXT:    [[VEC1:%.*]] = load <8 x i8>, ptr addrspace(1) [[GEP1]], align 8
; GFX906-NEXT:    [[VEC1_BC:%.*]] = bitcast <8 x i8> [[VEC1]] to <2 x i32>
; GFX906-NEXT:    [[GEP2:%.*]] = getelementptr <8 x i8>, ptr addrspace(1) [[SRC2]], i32 [[IDX]]
; GFX906-NEXT:    [[VEC2:%.*]] = load <8 x i8>, ptr addrspace(1) [[GEP2]], align 8
; GFX906-NEXT:    [[VEC2_BC:%.*]] = bitcast <8 x i8> [[VEC2]] to <2 x i32>
; GFX906-NEXT:    [[CMP:%.*]] = icmp ult i32 [[IDX]], 15
; GFX906-NEXT:    br i1 [[CMP]], label [[BB_1:%.*]], label [[BB_3:%.*]]
; GFX906:       bb.1:
; GFX906-NEXT:    [[CMP2:%.*]] = icmp ult i32 [[IDX]], 7
; GFX906-NEXT:    br i1 [[CMP2]], label [[BB_2:%.*]], label [[BB_3]]
; GFX906:       bb.2:
; GFX906-NEXT:    [[VEC1_BC_BC:%.*]] = bitcast <2 x i32> [[VEC1_BC]] to <8 x i8>
; GFX906-NEXT:    store <8 x i8> [[VEC1_BC_BC]], ptr addrspace(1) [[DST0]], align 4
; GFX906-NEXT:    br label [[BB_3]]
; GFX906:       bb.3:
; GFX906-NEXT:    [[TMP5_TC:%.*]] = phi <2 x i32> [ [[VEC1_BC]], [[ENTRY:%.*]] ], [ [[VEC2_BC]], [[BB_1]] ], [ [[VEC2_BC]], [[BB_2]] ]
; GFX906-NEXT:    [[TMP5_TC_BC:%.*]] = bitcast <2 x i32> [[TMP5_TC]] to <8 x i8>
; GFX906-NEXT:    store <8 x i8> [[TMP5_TC_BC]], ptr addrspace(1) [[DST1]], align 4
; GFX906-NEXT:    ret void
;
; FEATURE-LABEL: define amdgpu_kernel void @v8i8_multi_block(
; FEATURE-SAME: ptr addrspace(1) [[SRC1:%.*]], ptr addrspace(1) [[SRC2:%.*]], ptr addrspace(1) nocapture [[DST0:%.*]], ptr addrspace(1) nocapture [[DST1:%.*]]) #[[ATTR0]] {
; FEATURE-NEXT:  entry:
; FEATURE-NEXT:    [[IDX:%.*]] = call i32 @llvm.amdgcn.workitem.id.x()
; FEATURE-NEXT:    [[GEP1:%.*]] = getelementptr <8 x i8>, ptr addrspace(1) [[SRC1]], i32 [[IDX]]
; FEATURE-NEXT:    [[VEC1:%.*]] = load <8 x i8>, ptr addrspace(1) [[GEP1]], align 8
; FEATURE-NEXT:    [[VEC1_BC:%.*]] = bitcast <8 x i8> [[VEC1]] to <2 x i32>
; FEATURE-NEXT:    [[GEP2:%.*]] = getelementptr <8 x i8>, ptr addrspace(1) [[SRC2]], i32 [[IDX]]
; FEATURE-NEXT:    [[VEC2:%.*]] = load <8 x i8>, ptr addrspace(1) [[GEP2]], align 8
; FEATURE-NEXT:    [[VEC2_BC:%.*]] = bitcast <8 x i8> [[VEC2]] to <2 x i32>
; FEATURE-NEXT:    [[CMP:%.*]] = icmp ult i32 [[IDX]], 15
; FEATURE-NEXT:    br i1 [[CMP]], label [[BB_1:%.*]], label [[BB_3:%.*]]
; FEATURE:       bb.1:
; FEATURE-NEXT:    [[CMP2:%.*]] = icmp ult i32 [[IDX]], 7
; FEATURE-NEXT:    br i1 [[CMP2]], label [[BB_2:%.*]], label [[BB_3]]
; FEATURE:       bb.2:
; FEATURE-NEXT:    [[VEC1_BC_BC:%.*]] = bitcast <2 x i32> [[VEC1_BC]] to <8 x i8>
; FEATURE-NEXT:    store <8 x i8> [[VEC1_BC_BC]], ptr addrspace(1) [[DST0]], align 4
; FEATURE-NEXT:    br label [[BB_3]]
; FEATURE:       bb.3:
; FEATURE-NEXT:    [[PHI5_TC:%.*]] = phi <2 x i32> [ [[VEC1_BC]], [[ENTRY:%.*]] ], [ [[VEC2_BC]], [[BB_1]] ], [ [[VEC2_BC]], [[BB_2]] ]
; FEATURE-NEXT:    [[PHI5_TC_BC:%.*]] = bitcast <2 x i32> [[PHI5_TC]] to <8 x i8>
; FEATURE-NEXT:    store <8 x i8> [[PHI5_TC_BC]], ptr addrspace(1) [[DST1]], align 4
; FEATURE-NEXT:    ret void
;
; DEFAULT-LABEL: define amdgpu_kernel void @v8i8_multi_block(
; DEFAULT-SAME: ptr addrspace(1) [[SRC1:%.*]], ptr addrspace(1) [[SRC2:%.*]], ptr addrspace(1) nocapture [[DST0:%.*]], ptr addrspace(1) nocapture [[DST1:%.*]]) #[[ATTR0]] {
; DEFAULT-NEXT:  entry:
; DEFAULT-NEXT:    [[IDX:%.*]] = call i32 @llvm.amdgcn.workitem.id.x()
; DEFAULT-NEXT:    [[GEP1:%.*]] = getelementptr <8 x i8>, ptr addrspace(1) [[SRC1]], i32 [[IDX]]
; DEFAULT-NEXT:    [[VEC1:%.*]] = load <8 x i8>, ptr addrspace(1) [[GEP1]], align 8
; DEFAULT-NEXT:    [[GEP2:%.*]] = getelementptr <8 x i8>, ptr addrspace(1) [[SRC2]], i32 [[IDX]]
; DEFAULT-NEXT:    [[VEC2:%.*]] = load <8 x i8>, ptr addrspace(1) [[GEP2]], align 8
; DEFAULT-NEXT:    [[CMP:%.*]] = icmp ult i32 [[IDX]], 15
; DEFAULT-NEXT:    br i1 [[CMP]], label [[BB_1:%.*]], label [[BB_3:%.*]]
; DEFAULT:       bb.1:
; DEFAULT-NEXT:    [[CMP2:%.*]] = icmp ult i32 [[IDX]], 7
; DEFAULT-NEXT:    br i1 [[CMP2]], label [[BB_2:%.*]], label [[BB_3]]
; DEFAULT:       bb.2:
; DEFAULT-NEXT:    store <8 x i8> [[VEC1]], ptr addrspace(1) [[DST0]], align 4
; DEFAULT-NEXT:    br label [[BB_3]]
; DEFAULT:       bb.3:
; DEFAULT-NEXT:    [[PHI5:%.*]] = phi <8 x i8> [ [[VEC1]], [[ENTRY:%.*]] ], [ [[VEC2]], [[BB_1]] ], [ [[VEC2]], [[BB_2]] ]
; DEFAULT-NEXT:    store <8 x i8> [[PHI5]], ptr addrspace(1) [[DST1]], align 4
; DEFAULT-NEXT:    ret void
;
entry:
  %idx = call i32 @llvm.amdgcn.workitem.id.x()
  %gep1 = getelementptr <8 x i8>, ptr addrspace(1) %src1, i32 %idx
  %vec1 = load <8 x i8>, ptr addrspace(1) %gep1
  %gep2 = getelementptr <8 x i8>, ptr addrspace(1) %src2, i32 %idx
  %vec2 = load <8 x i8>, ptr addrspace(1) %gep2
  %cmp = icmp ult i32 %idx, 15
  br i1 %cmp, label %bb.1, label %bb.3
bb.1:
  %cmp2 = icmp ult i32 %idx, 7
  br i1 %cmp2, label %bb.2, label %bb.3

bb.2:
  store <8 x i8> %vec1, ptr addrspace(1) %dst0, align 4
  br label %bb.3

bb.3:
  %phi5 = phi <8 x i8> [ %vec1, %entry ], [ %vec2, %bb.1 ], [ %vec2, %bb.2]
  store <8 x i8> %phi5, ptr addrspace(1) %dst1, align 4
  ret void
}

define amdgpu_kernel void @v32i8_loop_carried(ptr addrspace(1) %src1, ptr addrspace(1) %src2, ptr addrspace(1) nocapture %dst) {
; GFX906-LABEL: define amdgpu_kernel void @v32i8_loop_carried(
; GFX906-SAME: ptr addrspace(1) [[SRC1:%.*]], ptr addrspace(1) [[SRC2:%.*]], ptr addrspace(1) nocapture [[DST:%.*]]) #[[ATTR0]] {
; GFX906-NEXT:  entry:
; GFX906-NEXT:    [[IDX:%.*]] = call i32 @llvm.amdgcn.workitem.id.x()
; GFX906-NEXT:    [[GEP1:%.*]] = getelementptr <32 x i8>, ptr addrspace(1) [[SRC1]], i32 [[IDX]]
; GFX906-NEXT:    [[VEC1:%.*]] = load <4 x i8>, ptr addrspace(1) [[GEP1]], align 4
; GFX906-NEXT:    [[VEC1_BC:%.*]] = bitcast <4 x i8> [[VEC1]] to i32
; GFX906-NEXT:    br label [[BB_1:%.*]]
; GFX906:       bb.1:
; GFX906-NEXT:    [[TEMP_TC:%.*]] = phi i32 [ [[VEC1_BC]], [[ENTRY:%.*]] ], [ [[VEC2_BC:%.*]], [[BB_1]] ]
; GFX906-NEXT:    [[TEMP_TC_BC:%.*]] = bitcast i32 [[TEMP_TC]] to <4 x i8>
; GFX906-NEXT:    [[VEC1_BC_BC:%.*]] = bitcast i32 [[VEC1_BC]] to <4 x i8>
; GFX906-NEXT:    [[VEC2:%.*]] = shufflevector <4 x i8> [[VEC1_BC_BC]], <4 x i8> [[TEMP_TC_BC]], <4 x i32> <i32 0, i32 2, i32 4, i32 6>
; GFX906-NEXT:    [[VEC2_BC]] = bitcast <4 x i8> [[VEC2]] to i32
; GFX906-NEXT:    [[CMP:%.*]] = icmp ult i32 [[IDX]], 15
; GFX906-NEXT:    br i1 [[CMP]], label [[BB_1]], label [[BB_2:%.*]]
; GFX906:       0:
; GFX906-NEXT:    br label [[BB_2]]
; GFX906:       bb.2:
; GFX906-NEXT:    [[VEC2_BC_BC:%.*]] = bitcast i32 [[VEC2_BC]] to <4 x i8>
; GFX906-NEXT:    store <4 x i8> [[VEC2_BC_BC]], ptr addrspace(1) [[DST]], align 4
; GFX906-NEXT:    ret void
;
; FEATURE-LABEL: define amdgpu_kernel void @v32i8_loop_carried(
; FEATURE-SAME: ptr addrspace(1) [[SRC1:%.*]], ptr addrspace(1) [[SRC2:%.*]], ptr addrspace(1) nocapture [[DST:%.*]]) #[[ATTR0]] {
; FEATURE-NEXT:  entry:
; FEATURE-NEXT:    [[IDX:%.*]] = call i32 @llvm.amdgcn.workitem.id.x()
; FEATURE-NEXT:    [[GEP1:%.*]] = getelementptr <32 x i8>, ptr addrspace(1) [[SRC1]], i32 [[IDX]]
; FEATURE-NEXT:    [[VEC1:%.*]] = load <4 x i8>, ptr addrspace(1) [[GEP1]], align 4
; FEATURE-NEXT:    [[VEC1_BC:%.*]] = bitcast <4 x i8> [[VEC1]] to i32
; FEATURE-NEXT:    br label [[BB_1:%.*]]
; FEATURE:       bb.1:
; FEATURE-NEXT:    [[TEMP_TC:%.*]] = phi i32 [ [[VEC1_BC]], [[ENTRY:%.*]] ], [ [[VEC2_BC:%.*]], [[BB_1]] ]
; FEATURE-NEXT:    [[TEMP_TC_BC:%.*]] = bitcast i32 [[TEMP_TC]] to <4 x i8>
; FEATURE-NEXT:    [[VEC1_BC_BC:%.*]] = bitcast i32 [[VEC1_BC]] to <4 x i8>
; FEATURE-NEXT:    [[VEC2:%.*]] = shufflevector <4 x i8> [[VEC1_BC_BC]], <4 x i8> [[TEMP_TC_BC]], <4 x i32> <i32 0, i32 2, i32 4, i32 6>
; FEATURE-NEXT:    [[VEC2_BC]] = bitcast <4 x i8> [[VEC2]] to i32
; FEATURE-NEXT:    [[CMP:%.*]] = icmp ult i32 [[IDX]], 15
; FEATURE-NEXT:    br i1 [[CMP]], label [[BB_1]], label [[BB_2:%.*]]
; FEATURE:       0:
; FEATURE-NEXT:    br label [[BB_2]]
; FEATURE:       bb.2:
; FEATURE-NEXT:    [[VEC2_BC_BC:%.*]] = bitcast i32 [[VEC2_BC]] to <4 x i8>
; FEATURE-NEXT:    store <4 x i8> [[VEC2_BC_BC]], ptr addrspace(1) [[DST]], align 4
; FEATURE-NEXT:    ret void
;
; DEFAULT-LABEL: define amdgpu_kernel void @v32i8_loop_carried(
; DEFAULT-SAME: ptr addrspace(1) [[SRC1:%.*]], ptr addrspace(1) [[SRC2:%.*]], ptr addrspace(1) nocapture [[DST:%.*]]) #[[ATTR0]] {
; DEFAULT-NEXT:  entry:
; DEFAULT-NEXT:    [[IDX:%.*]] = call i32 @llvm.amdgcn.workitem.id.x()
; DEFAULT-NEXT:    [[GEP1:%.*]] = getelementptr <32 x i8>, ptr addrspace(1) [[SRC1]], i32 [[IDX]]
; DEFAULT-NEXT:    [[VEC1:%.*]] = load <4 x i8>, ptr addrspace(1) [[GEP1]], align 4
; DEFAULT-NEXT:    br label [[BB_1:%.*]]
; DEFAULT:       bb.1:
; DEFAULT-NEXT:    [[TEMP:%.*]] = phi <4 x i8> [ [[VEC1]], [[ENTRY:%.*]] ], [ [[VEC2:%.*]], [[BB_1]] ]
; DEFAULT-NEXT:    [[VEC2]] = shufflevector <4 x i8> [[VEC1]], <4 x i8> [[TEMP]], <4 x i32> <i32 0, i32 2, i32 4, i32 6>
; DEFAULT-NEXT:    [[CMP:%.*]] = icmp ult i32 [[IDX]], 15
; DEFAULT-NEXT:    br i1 [[CMP]], label [[BB_1]], label [[BB_2:%.*]]
; DEFAULT:       0:
; DEFAULT-NEXT:    br label [[BB_2]]
; DEFAULT:       bb.2:
; DEFAULT-NEXT:    store <4 x i8> [[VEC2]], ptr addrspace(1) [[DST]], align 4
; DEFAULT-NEXT:    ret void
;
entry:
  %idx = call i32 @llvm.amdgcn.workitem.id.x()
  %gep1 = getelementptr <32 x i8>, ptr addrspace(1) %src1, i32 %idx
  %vec1 = load <4 x i8>, ptr addrspace(1) %gep1
  br label %bb.1

bb.1:
  %temp = phi <4 x i8> [ %vec1, %entry ], [ %vec2, %bb.1 ]
  %vec2 = shufflevector <4 x i8> %vec1, <4 x i8> %temp, <4 x i32> <i32 0, i32 2, i32 4, i32 6>
  %cmp = icmp ult i32 %idx, 15
  br i1 %cmp, label %bb.1, label %bb.2
  br label %bb.2

bb.2:
  store <4 x i8> %vec2, ptr addrspace(1) %dst, align 4
  ret void
}

; Should not produce a broken phi

define void @broken_phi() {
; GFX906-LABEL: define void @broken_phi(
; GFX906-SAME: ) #[[ATTR0]] {
; GFX906-NEXT:  bb:
; GFX906-NEXT:    br label [[BB1:%.*]]
; GFX906:       bb1:
; GFX906-NEXT:    [[I:%.*]] = phi <4 x i8> [ <i8 1, i8 1, i8 1, i8 1>, [[BB:%.*]] ], [ [[I8:%.*]], [[BB7:%.*]] ]
; GFX906-NEXT:    br i1 false, label [[BB3:%.*]], label [[BB2:%.*]]
; GFX906:       bb2:
; GFX906-NEXT:    br label [[BB3]]
; GFX906:       bb3:
; GFX906-NEXT:    [[I4:%.*]] = phi <4 x i8> [ zeroinitializer, [[BB2]] ], [ [[I]], [[BB1]] ]
; GFX906-NEXT:    br i1 false, label [[BB7]], label [[BB5:%.*]]
; GFX906:       bb5:
; GFX906-NEXT:    [[I6:%.*]] = call <4 x i8> @llvm.smax.v4i8(<4 x i8> [[I4]], <4 x i8> zeroinitializer)
; GFX906-NEXT:    br label [[BB7]]
; GFX906:       bb7:
; GFX906-NEXT:    [[I8]] = phi <4 x i8> [ zeroinitializer, [[BB5]] ], [ zeroinitializer, [[BB3]] ]
; GFX906-NEXT:    br label [[BB1]]
;
; FEATURE-LABEL: define void @broken_phi(
; FEATURE-SAME: ) #[[ATTR0]] {
; FEATURE-NEXT:  bb:
; FEATURE-NEXT:    br label [[BB1:%.*]]
; FEATURE:       bb1:
; FEATURE-NEXT:    [[I:%.*]] = phi <4 x i8> [ <i8 1, i8 1, i8 1, i8 1>, [[BB:%.*]] ], [ [[I8:%.*]], [[BB7:%.*]] ]
; FEATURE-NEXT:    br i1 false, label [[BB3:%.*]], label [[BB2:%.*]]
; FEATURE:       bb2:
; FEATURE-NEXT:    br label [[BB3]]
; FEATURE:       bb3:
; FEATURE-NEXT:    [[I4:%.*]] = phi <4 x i8> [ zeroinitializer, [[BB2]] ], [ [[I]], [[BB1]] ]
; FEATURE-NEXT:    br i1 false, label [[BB7]], label [[BB5:%.*]]
; FEATURE:       bb5:
; FEATURE-NEXT:    [[I6:%.*]] = call <4 x i8> @llvm.smax.v4i8(<4 x i8> [[I4]], <4 x i8> zeroinitializer)
; FEATURE-NEXT:    br label [[BB7]]
; FEATURE:       bb7:
; FEATURE-NEXT:    [[I8]] = phi <4 x i8> [ zeroinitializer, [[BB5]] ], [ zeroinitializer, [[BB3]] ]
; FEATURE-NEXT:    br label [[BB1]]
;
; DEFAULT-LABEL: define void @broken_phi(
; DEFAULT-SAME: ) #[[ATTR0]] {
; DEFAULT-NEXT:  bb:
; DEFAULT-NEXT:    br label [[BB1:%.*]]
; DEFAULT:       bb1:
; DEFAULT-NEXT:    [[I:%.*]] = phi <4 x i8> [ <i8 1, i8 1, i8 1, i8 1>, [[BB:%.*]] ], [ [[I8:%.*]], [[BB7:%.*]] ]
; DEFAULT-NEXT:    br i1 false, label [[BB3:%.*]], label [[BB2:%.*]]
; DEFAULT:       bb2:
; DEFAULT-NEXT:    br label [[BB3]]
; DEFAULT:       bb3:
; DEFAULT-NEXT:    [[I4:%.*]] = phi <4 x i8> [ zeroinitializer, [[BB2]] ], [ [[I]], [[BB1]] ]
; DEFAULT-NEXT:    br i1 false, label [[BB7]], label [[BB5:%.*]]
; DEFAULT:       bb5:
; DEFAULT-NEXT:    [[I6:%.*]] = call <4 x i8> @llvm.smax.v4i8(<4 x i8> [[I4]], <4 x i8> zeroinitializer)
; DEFAULT-NEXT:    br label [[BB7]]
; DEFAULT:       bb7:
; DEFAULT-NEXT:    [[I8]] = phi <4 x i8> [ zeroinitializer, [[BB5]] ], [ zeroinitializer, [[BB3]] ]
; DEFAULT-NEXT:    br label [[BB1]]
;
bb:
  br label %bb1
bb1:
  %i = phi <4 x i8> [ <i8 1, i8 1, i8 1, i8 1>, %bb ], [ %i8, %bb7 ]
  br i1 false, label %bb3, label %bb2
bb2:
  br label %bb3
bb3:
  %i4 = phi <4 x i8> [ zeroinitializer, %bb2 ], [ %i, %bb1 ]
  br i1 false, label %bb7, label %bb5
bb5:
  %i6 = call <4 x i8> @llvm.smax.v4i8(<4 x i8> %i4, <4 x i8> zeroinitializer)
  br label %bb7
bb7:
  %i8 = phi <4 x i8> [ zeroinitializer, %bb5 ], [ zeroinitializer, %bb3 ]
  br label %bb1
}

; %sel1 should just use %sel0 instead of trying to convert back the
; converted version of %sel0

define amdgpu_kernel void @reuseOp() {
; GFX906-LABEL: define amdgpu_kernel void @reuseOp(
; GFX906-SAME: ) #[[ATTR0]] {
; GFX906-NEXT:  entry:
; GFX906-NEXT:    [[VEC1:%.*]] = insertelement <16 x i8> zeroinitializer, i8 0, i64 0
; GFX906-NEXT:    [[VEC1_BC:%.*]] = bitcast <16 x i8> [[VEC1]] to <4 x i32>
; GFX906-NEXT:    br label [[BB_1:%.*]]
; GFX906:       bb.1:
; GFX906-NEXT:    [[VEC1_BC_BC:%.*]] = bitcast <4 x i32> [[VEC1_BC]] to <16 x i8>
; GFX906-NEXT:    [[SEL0:%.*]] = select i1 false, <16 x i8> zeroinitializer, <16 x i8> zeroinitializer
; GFX906-NEXT:    [[SEL0_BC:%.*]] = bitcast <16 x i8> [[SEL0]] to <4 x i32>
; GFX906-NEXT:    [[SEL1:%.*]] = select i1 false, <16 x i8> [[VEC1_BC_BC]], <16 x i8> [[SEL0]]
; GFX906-NEXT:    br label [[BB_2:%.*]]
; GFX906:       bb.2:
; GFX906-NEXT:    [[SEL0_BC_BC:%.*]] = bitcast <4 x i32> [[SEL0_BC]] to <16 x i8>
; GFX906-NEXT:    [[VAL:%.*]] = extractelement <16 x i8> [[SEL0_BC_BC]], i64 0
; GFX906-NEXT:    ret void
;
; FEATURE-LABEL: define amdgpu_kernel void @reuseOp(
; FEATURE-SAME: ) #[[ATTR0]] {
; FEATURE-NEXT:  entry:
; FEATURE-NEXT:    [[VEC1:%.*]] = insertelement <16 x i8> zeroinitializer, i8 0, i64 0
; FEATURE-NEXT:    [[VEC1_BC:%.*]] = bitcast <16 x i8> [[VEC1]] to <4 x i32>
; FEATURE-NEXT:    br label [[BB_1:%.*]]
; FEATURE:       bb.1:
; FEATURE-NEXT:    [[VEC1_BC_BC:%.*]] = bitcast <4 x i32> [[VEC1_BC]] to <16 x i8>
; FEATURE-NEXT:    [[SEL0:%.*]] = select i1 false, <16 x i8> zeroinitializer, <16 x i8> zeroinitializer
; FEATURE-NEXT:    [[SEL0_BC:%.*]] = bitcast <16 x i8> [[SEL0]] to <4 x i32>
; FEATURE-NEXT:    [[SEL1:%.*]] = select i1 false, <16 x i8> [[VEC1_BC_BC]], <16 x i8> [[SEL0]]
; FEATURE-NEXT:    br label [[BB_2:%.*]]
; FEATURE:       bb.2:
; FEATURE-NEXT:    [[SEL0_BC_BC:%.*]] = bitcast <4 x i32> [[SEL0_BC]] to <16 x i8>
; FEATURE-NEXT:    [[VAL:%.*]] = extractelement <16 x i8> [[SEL0_BC_BC]], i64 0
; FEATURE-NEXT:    ret void
;
; DEFAULT-LABEL: define amdgpu_kernel void @reuseOp(
; DEFAULT-SAME: ) #[[ATTR0]] {
; DEFAULT-NEXT:  entry:
; DEFAULT-NEXT:    [[VEC1:%.*]] = insertelement <16 x i8> zeroinitializer, i8 0, i64 0
; DEFAULT-NEXT:    br label [[BB_1:%.*]]
; DEFAULT:       bb.1:
; DEFAULT-NEXT:    [[SEL0:%.*]] = select i1 false, <16 x i8> zeroinitializer, <16 x i8> zeroinitializer
; DEFAULT-NEXT:    [[SEL1:%.*]] = select i1 false, <16 x i8> [[VEC1]], <16 x i8> [[SEL0]]
; DEFAULT-NEXT:    br label [[BB_2:%.*]]
; DEFAULT:       bb.2:
; DEFAULT-NEXT:    [[VAL:%.*]] = extractelement <16 x i8> [[SEL0]], i64 0
; DEFAULT-NEXT:    ret void
;
entry:
  %vec1 = insertelement <16 x i8> zeroinitializer, i8 0, i64 0
  br label %bb.1

bb.1:
  %sel0 = select i1 false, <16 x i8> zeroinitializer, <16 x i8> zeroinitializer
  %sel1 = select i1 false, <16 x i8> %vec1, <16 x i8> %sel0
  br label %bb.2

bb.2:
  %val = extractelement <16 x i8> %sel0, i64 0
  ret void
}


declare i32 @llvm.amdgcn.workitem.id.x()
